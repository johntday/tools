/L20"Haskell" Line Comment = -- Block Comment On = {- Block Comment Off = -} String Chars = "' File Extensions = HS LHS XHS
/Delimiters = (){}[];,` 	
/C1
(
)
Addr
EQ EmptyRec EmptyRow
Either
False FilePath
GT 
Hugs_Error Hugs_ExitWith Hugs_Return Hugs_SuspendThread
IO IOError IOResult
Just
LT Left
Maybe
Nothing
Ordering
Rec Right Ratio Rational
ST
True 
/C2
_
= =>
| 
<-
->
, 
..
: ::
class case
data deriving do
else
import instance if in
let
module
newtype
of
primitive
type then
where
/C3
&&
||
// /= /
==
! !!
+ ++
-
* **
< <=
> >> >>= >=
abs absReal accumulate acos acosh all and any appendFile applyM approxRational asTypeOf asciiTab asin asinh atan atan2 atanh
break
catch ceiling chr compare concat concatMap const cos cosh curry cycle
decodeFloat denominator digitToInt div divMod doubleToFloat doubleToRatio doubleToRational drop dropWhile
either elem encodeFloat enumFrom enumFromThen enumFromThenTo enumFromTo error even exp exponent
fail filter flip floatDigits floatProperFraction floatRadix floatRange floatToRational floor foldl foldl' foldl1 foldr foldr1 fromDouble fromEnum fromInt fromInteger fromIntegral fromRational fromRealFrac fst
gcd getChar getContents getLine guard
head hugsIORun hugsPutStr
id inRange index init intToDigit intToRatio interact ioeGetErrorString isAlpha isAlphanum isAscii isControl isDenormalized isDigit isHexDigit isIEEE isInfinite isLower isNaN isNegativeZero isOctDigit isPrint isSpace isUpper iterate
last lcm length lex lexDigits lexLitChar lexmatch lines log logBase lookup
map mapM mapM_ max maxBound maximum maybe min minBound minimum mod
negate nonnull not notElem null numerator numericEnumFrom numericEnumFromThen numericEnumFromThenTo numericEnumFromTo
odd or ord otherwise
pi pred primAcosDouble primAcosFloat primAsinDouble primAsinFloat primAtanDouble primAtanFloat primCharToInt primCmpChar primCmpDouble primCmpFloat primCmpInt primCmpInteger primCompAux primCosDouble primCosFloat primDivDouble primDivFloat primDivInt primDoubleDecode primDoubleDigits primDoubleEncode primDoubleMaxExp primDoubleMinExp primDoubleRadix primEqChar primEqDouble primEqFloat primEqInt primEqInteger primEvenInt primEvenInteger primExitWith primExpDouble primExpFloat primFloatDecode primFloatDigits primFloatEncode primFloatMaxExp primFloatMinExp primFloatRadix primIntToChar primIntToDouble primIntToFloat primIntToInteger primIntegerToDouble primIntegerToFloat primIntegerToInt primLogDouble primLogFloat primMaxInt primMinInt primMinusDouble primMinusFloat primMinusInt primMinusInteger primModInt primMulDouble primMulFloat primMulInt primMulInteger primNegDouble primNegFloat primNegInt primNegInteger primPiDouble primPiFloat primPlusDouble primPlusFloat primPlusInt primPlusInteger primPmFlt primPmInt primPmInteger primPmNpk primPmSub primQrmInt primQrmInteger primQuotInt primRationalToDouble primRationalToFloat primRemInt primShowsDouble primShowsFloat primShowsInt primShowsInteger primSinDouble primSinFloat primSqrtDouble primSqrtFloat primTanDouble primTanFloat primbindIO primretIO print product properFraction protectEsc putChar putStr putStrLn
quot quotRem
range rangeSize rationalToDouble rationalToFloat rationalToRealFloat read readDec readField readFile readFloat readHex readIO readInt readList readLitChar readLn readOct readParen readSigned reads readsPrec realFloatToRational recip reduce rem repeat replicate return reverse round
scaleFloat scanl scanl1 scanr scanr1 seq sequence show showChar showField showInt showList showLitChar showParen showSigned showString shows showsPrec significand signum signumReal sin sinh snd span splitAt sqrt strict subtract succ sum
tail take takeWhile tan tanh toEnum toInt toInteger toLower toRational toUpper truncate
uncurry undefined unlines until unwords unzip unzip3 userError
words writeFile
zero zip zip3 zipWith zipWith3
/C4
Bool 
Char
Float
Int Integer
Long
String 
/C5
Bounded
Double
Enum Eq Eval
Functor Fractional Floating
Ix Integral
Monad MonadZero MonadPlus
Num
Ord
Read Real RealFrac RealFloat
Show
Void